<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>aidraw – browser AI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    :root {
      --bg: #050816;
      --panel: #101827;
      --accent: #4f46e5;
      --accent-soft: #4caf50;
      --border: #1f2937;
      --text: #f9fafb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%);
      color: var(--text);
      display: flex;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 480px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 10px;
    }

    header {
      padding: 8px 10px;
      border-radius: 12px;
      background: linear-gradient(135deg, #111827, #020617);
      border: 1px solid var(--border);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.8);
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    header h1 span.logo-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #38bdf8, #6366f1);
      box-shadow: 0 0 12px rgba(129, 140, 248, 0.8);
    }

    header p {
      margin: 4px 0 0;
      font-size: 12px;
      color: var(--muted);
    }

    #canvas-wrapper {
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      background: #020617;
      box-shadow: 0 16px 35px rgba(15, 23, 42, 0.9);
    }

    #canvas {
      display: block;
      width: 100%;
      height: auto;
      max-height: 65vh;
      touch-action: none;
      background: radial-gradient(circle at top, #020617 0, #000 55%);
    }

    #labels {
      display: flex;
      font-size: 11px;
      color: var(--muted);
      border-top: 1px solid #111827;
      background: #030712;
    }

    #labels div {
      flex: 1;
      text-align: center;
      padding: 4px 0 6px;
    }

    #labels span.dot {
      display: inline-block;
      width: 7px;
      height: 7px;
      border-radius: 999px;
      margin-right: 4px;
    }

    #labels .orig span.dot {
      background: #f9fafb;
    }

    #labels .ai span.dot {
      background: #60a5fa;
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 6px 2px;
      align-items: center;
      justify-content: center;
    }

    button {
      border: 1px solid #1f2937;
      background: #020617;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.6);
      transition: transform 0.06s ease, box-shadow 0.06s ease, background 0.1s;
    }

    button span.btn-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #4ade80;
    }

    button.primary {
      background: linear-gradient(135deg, #4f46e5, #22d3ee);
      border-color: transparent;
    }

    button.secondary {
      background: #020617;
    }

    button:active {
      transform: scale(0.97) translateY(1px);
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.4);
    }

    #status {
      flex: 1 1 100%;
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }

    #progress-wrapper {
      padding: 0 4px 4px;
    }

    #epoch-label {
      font-size: 11px;
      margin-bottom: 4px;
      color: var(--muted);
      text-align: center;
      min-height: 14px;
    }

    #progress-container {
      width: 100%;
      height: 8px;
      background: #020617;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #111827;
    }

    #progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #22c55e, #a3e635);
      transition: width 0.1s linear;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
    }

    footer {
      margin-top: auto;
      text-align: center;
      font-size: 10px;
      color: #4b5563;
      padding-top: 4px;
    }

    @media (min-width: 768px) {
      .app {
        max-width: 600px;
        padding-top: 18px;
      }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <h1><span class="logo-dot"></span>aidraw <span style="font-size:11px; opacity:0.7;">web</span></h1>
      <p>Draw on top, watch the tiny neural net learn to copy you on the bottom.</p>
    </header>

    <div id="canvas-wrapper">
      <canvas id="canvas" width="360" height="510"></canvas>
      <div id="labels">
        <div class="orig"><span class="dot"></span>Original</div>
        <div class="ai"><span class="dot"></span>AI prediction</div>
      </div>
    </div>

    <div id="controls">
      <button id="btn-train" class="primary">
        <span class="btn-dot"></span> AI Draw
      </button>
      <button id="btn-clear" class="secondary">Clear</button>
      <button id="btn-download-model" class="secondary">Download Model</button>
      <button id="btn-save-rawdata" class="secondary">Save Rawdata</button>
      <div id="status"></div>
    </div>

    <div id="progress-wrapper">
      <div id="epoch-label"></div>
      <div id="progress-container">
        <div id="progress-bar"></div>
      </div>
    </div>

    <footer>Best viewed in portrait · model resets when you reload</footer>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const epochLabel = document.getElementById("epoch-label");
    const progressBar = document.getElementById("progress-bar");

    const origHeight = canvas.height / 2;

    let drawing = false;
    let originalPoints = [];
    let aiPoints = null;
    let model = null;
    let drawTimeoutId = null;  // 400ms stroke timer
    let isTraining = false;

    function setStatus(msg) { statusEl.textContent = msg; }

    function resetProgress() {
      epochLabel.textContent = "";
      progressBar.style.width = "0%";
    }

    function updateProgress(epoch, loss, totalEpochs) {
      const pct = ((epoch + 1) / totalEpochs) * 100;
      progressBar.style.width = pct + "%";
      epochLabel.textContent =
        `Training epoch ${epoch + 1}/${totalEpochs}` +
        (loss != null ? ` · loss: ${loss.toFixed(4)}` : "");
    }

    function clearCanvas() {
      // Whole canvas dark again
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Divider line
      ctx.strokeStyle = "#111827";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, origHeight + 0.5);
      ctx.lineTo(canvas.width, origHeight + 0.5);
      ctx.stroke();
    }

    function screenToNormOriginal(x, y) {
      const cx = Math.max(0, Math.min(x, canvas.width - 1));
      const cy = Math.max(0, Math.min(y, origHeight - 1));
      const nx = cx / canvas.width;
      const ny = 1 - (cy / origHeight);
      return [nx, ny];
    }

    function normToScreenOriginal(x, y) {
      const sx = x * canvas.width;
      const sy = (1 - y) * origHeight;
      return [sx, sy];
    }

    function normToScreenAI(x, y) {
      const sx = x * canvas.width;
      const sy = (1 - y) * origHeight + origHeight;
      return [sx, sy];
    }

    function drawStroke(points, toScreenFn, color) {
      if (!points || points.length < 2) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      let [x0, y0] = toScreenFn(points[0][0], points[0][1]);
      ctx.moveTo(x0, y0);
      for (let i = 1; i < points.length; i++) {
        let [x, y] = toScreenFn(points[i][0], points[i][1]);
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function redraw(showAI = false) {
      clearCanvas();
      if (originalPoints.length > 1) {
        // back to light stroke on dark bg
        drawStroke(originalPoints, normToScreenOriginal, "#e5e7eb");
      }
      if (showAI && aiPoints && aiPoints.length > 1) {
        drawStroke(aiPoints, normToScreenAI, "#60a5fa");
      }
    }

    clearCanvas();

    function getCanvasPosFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
      };
    }

    function getCanvasPosFromTouch(e) {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0] || e.changedTouches[0];
      return {
        x: t.clientX - rect.left,
        y: t.clientY - rect.top,
      };
    }

    function stopDrawing(msg) {
      drawing = false;
      if (drawTimeoutId) {
        clearTimeout(drawTimeoutId);
        drawTimeoutId = null;
      }

      if (originalPoints.length < 5) {
        setStatus("Stroke too short. Draw a longer stroke on the top half.");
        return;
      }

      setStatus((msg ? msg + " " : "") + "Training AI...");
      // Auto-start training after stroke is done
      trainModelOnStroke(originalPoints);
    }

    // Mouse drawing
    canvas.addEventListener("mousedown", (e) => {
      if (isTraining) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromMouse(e);
      if (y >= origHeight) return;
      drawing = true;
      originalPoints = [];
      aiPoints = null;
      resetProgress();
      const [nx, ny] = screenToNormOriginal(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
      setStatus("Recording stroke...");

      if (drawTimeoutId) clearTimeout(drawTimeoutId);
      drawTimeoutId = setTimeout(() => {
        if (drawing) {
          stopDrawing(`Recorded ${originalPoints.length} points (time limit).`);
        }
      }, 400);
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromMouse(e);
      if (y >= origHeight) return;
      const [nx, ny] = screenToNormOriginal(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
    });

    canvas.addEventListener("mouseup", (e) => {
      e.preventDefault();
      if (!drawing) return;
      stopDrawing(`Recorded ${originalPoints.length} points.`);
    });

    canvas.addEventListener("mouseleave", () => {
      if (!drawing) return;
      stopDrawing(`Recorded ${originalPoints.length} points.`);
    });

    // Touch drawing
    canvas.addEventListener("touchstart", (e) => {
      if (isTraining) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromTouch(e);
      if (y >= origHeight) return;
      drawing = true;
      originalPoints = [];
      aiPoints = null;
      resetProgress();
      const [nx, ny] = screenToNormOriginal(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
      setStatus("Recording stroke...");

      if (drawTimeoutId) clearTimeout(drawTimeoutId);
      drawTimeoutId = setTimeout(() => {
        if (drawing) {
          stopDrawing(`Recorded ${originalPoints.length} points (time limit).`);
        }
      }, 400);
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      if (!drawing) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromTouch(e);
      if (y >= origHeight) return;
      const [nx, ny] = screenToNormOriginal(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (!drawing) return;
      stopDrawing(`Recorded ${originalPoints.length} points.`);
    }, { passive: false });

    // Model
    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.dense({ units: 64, inputShape: [1], activation: "tanh" }));
      m.add(tf.layers.dense({ units: 64, activation: "tanh" }));
      m.add(tf.layers.dense({ units: 2 }));
      m.compile({
        optimizer: tf.train.adam(0.01),
        loss: "meanSquaredError",
      });
      return m;
    }

    (async () => {
      try {
        await tf.setBackend('webgl');
      } catch (e) {
        console.warn("Could not set WebGL backend:", e);
      }
      await tf.ready();
    })();

    async function trainModelOnStroke(points) {
      if (isTraining) {
        setStatus("Already training. Please wait.");
        return;
      }

      const T = points.length;
      const totalEpochs = 600;                    // fixed to 600
      const previewEvery = 5;

      const tTrain = tf.linspace(0, 1, T).reshape([T, 1]);
      const y = tf.tensor2d(points);

      model = buildModel();
      resetProgress();
      aiPoints = null;
      redraw(false);

      isTraining = true;
      try {
        await model.fit(tTrain, y, {
          epochs: totalEpochs,
          batchSize: 32,
          shuffle: true,
          callbacks: {
            onEpochEnd: (epoch, logs) => {
              updateProgress(epoch, logs.loss, totalEpochs);

              if ((epoch + 1) % previewEvery === 0 || epoch + 1 === totalEpochs) {
                tf.tidy(() => {
                  const tPred = tf.linspace(0, 1, T).reshape([T, 1]);
                  const pred = model.predict(tPred);
                  const data = pred.dataSync();
                  const pts = [];
                  for (let i = 0; i < T; i++) {
                    let x = data[2 * i];
                    let yv = data[2 * i + 1];
                    x  = Math.min(Math.max(x, 0), 1);
                    yv = Math.min(Math.max(yv, 0), 1);
                    pts.push([x, yv]);
                  }
                  aiPoints = pts;
                });
                redraw(true);
              }
            }
          }
        });

        setStatus("Training done. AI stroke is shown on the bottom.");
      } catch (e) {
        console.error(e);
        setStatus("Training failed.");
      } finally {
        tTrain.dispose();
        y.dispose();
        isTraining = false;
      }
    }

    // Rawdata saver
    function saveRawdata() {
      if (originalPoints.length < 5) {
        setStatus("No stroke data to save.");
        return;
      }
      const lines = [];
      lines.push("RUNS = [");
      lines.push("    [  # one run");
      for (const [x, y] of originalPoints) {
        lines.push(`        [${x.toFixed(6)}, ${y.toFixed(6)}],`);
      }
      lines.push("    ],");
      lines.push("]");
      const blob = new Blob([lines.join("\n")], { type: "text/x-python" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "rawdata.py";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setStatus("Saved rawdata.py");
    }

    // Buttons
    document.getElementById("btn-train").onclick = async () => {
      if (originalPoints.length < 5) {
        setStatus("Draw something on the top half first.");
        return;
      }
      setStatus("Training AI...");
      await trainModelOnStroke(originalPoints);
    };

    document.getElementById("btn-clear").onclick = () => {
      if (isTraining) {
        setStatus("Cannot clear while training.");
        return;
      }
      originalPoints = [];
      aiPoints = null;
      clearCanvas();
      resetProgress();
      if (drawTimeoutId) {
        clearTimeout(drawTimeoutId);
        drawTimeoutId = null;
      }
      setStatus("Cleared.");
    };

    document.getElementById("btn-download-model").onclick = async () => {
      if (!model) {
        setStatus("No model yet. Use AI Draw first.");
        return;
      }
      try {
        await model.save("downloads://aidraw_model");
        setStatus("Model downloaded (aidraw_model.*).");
      } catch (e) {
        console.error(e);
        setStatus("Failed to download model.");
      }
    };

    document.getElementById("btn-save-rawdata").onclick = () => {
      saveRawdata();
    };
  </script>
</body>
</html>
