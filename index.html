<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>aidraw – browser AI</title>
  <style>
    body { margin: 0; font-family: system-ui, sans-serif; background: #fafafa; }
    #canvas {
      display: block;
      border-bottom: 1px solid #ccc;
      background: #fff;
      touch-action: none; /* prevent page scroll / zoom on touch */
    }
    #controls { padding: 8px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button { padding: 6px 10px; cursor: pointer; }
    #status { margin-left: 12px; font-size: 14px; min-width: 200px; }
    #progress-wrapper {
      width: 100%;
      padding: 0 8px 8px 8px;
      box-sizing: border-box;
    }
    #epoch-label { font-size: 13px; margin-bottom: 4px; display: block; }
    #progress-container {
      width: 100%;
      max-width: 400px;
      height: 10px;
      background: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
    }
    #progress-bar {
      height: 100%;
      width: 0%;
      background: #4caf50; /* green car */
      transition: width 0.1s linear;
    }
  </style>
  <!-- Real neural net in the browser -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
</head>
<body>
  <canvas id="canvas" width="800" height="400"></canvas>

  <div id="controls">
    <button id="btn-train">Train AI</button>
    <button id="btn-draw-ai">Draw with AI</button>
    <button id="btn-clear">Clear</button>
    <button id="btn-save">Save Image</button>
    <span id="status"></span>
  </div>

  <div id="progress-wrapper">
    <span id="epoch-label"></span>
    <div id="progress-container">
      <div id="progress-bar"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const leftWidth = canvas.width / 2;

    const epochLabel = document.getElementById("epoch-label");
    const progressBar = document.getElementById("progress-bar");

    const TOTAL_EPOCHS = 2500;

    let drawing = false;
    let originalPoints = [];   // [[x,y] in 0–1]
    let aiPoints = null;
    let model = null;

    function setStatus(msg) { statusEl.textContent = msg; }

    function resetProgress() {
      epochLabel.textContent = "";
      progressBar.style.width = "0%";
    }

    function updateProgress(epoch, loss) {
      const pct = ((epoch + 1) / TOTAL_EPOCHS) * 100;
      progressBar.style.width = pct + "%";
      epochLabel.textContent = `Training epoch ${epoch + 1}/${TOTAL_EPOCHS}` +
        (loss != null ? `   loss: ${loss.toFixed(4)}` : "");
    }

    function clearCanvas() {
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#e0e0e0";
      ctx.strokeRect(0, 0, leftWidth, canvas.height);
      ctx.strokeRect(leftWidth, 0, leftWidth, canvas.height);
    }

    function screenToNorm(x, y) {
      const nx = Math.max(0, Math.min(x, leftWidth - 1)) / leftWidth;
      const ny = 1 - (Math.max(0, Math.min(y, canvas.height - 1)) / canvas.height);
      return [nx, ny];
    }

    function normToScreenLeft(x, y) {
      return [x * leftWidth, (1 - y) * canvas.height];
    }

    function normToScreenRight(x, y) {
      return [leftWidth + x * leftWidth, (1 - y) * canvas.height];
    }

    function drawStroke(points, toScreenFn, color) {
      if (!points || points.length < 2) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      let [x0, y0] = toScreenFn(points[0][0], points[0][1]);
      ctx.moveTo(x0, y0);
      for (let i = 1; i < points.length; i++) {
        let [x, y] = toScreenFn(points[i][0], points[i][1]);
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function redraw(showAI = false) {
      clearCanvas();
      if (originalPoints.length > 1) {
        drawStroke(originalPoints, normToScreenLeft, "#000000");
      }
      if (showAI && aiPoints && aiPoints.length > 1) {
        drawStroke(aiPoints, normToScreenRight, "#0000ff");
      }
    }

    clearCanvas();

    function getCanvasPosFromMouse(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
      };
    }

    function getCanvasPosFromTouch(e) {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0] || e.changedTouches[0];
      return {
        x: t.clientX - rect.left,
        y: t.clientY - rect.top,
      };
    }

    // ── Mouse drawing (left half only) ─────────────────
    canvas.addEventListener("mousedown", (e) => {
      e.preventDefault();
      const { x, y } = getCanvasPosFromMouse(e);
      if (y >= canvas.height || x >= leftWidth) return;
      drawing = true;
      originalPoints = [];
      aiPoints = null;
      resetProgress();
      const [nx, ny] = screenToNorm(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
      setStatus("Recording stroke...");
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromMouse(e);
      if (y >= canvas.height || x >= leftWidth) return;
      const [nx, ny] = screenToNorm(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
    });

    canvas.addEventListener("mouseup", (e) => {
      e.preventDefault();
      if (!drawing) return;
      drawing = false;
      setStatus(`Recorded ${originalPoints.length} points.`);
    });

    canvas.addEventListener("mouseleave", () => { drawing = false; });

    // ── Touch drawing (left half only, prevent scroll) ─
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const { x, y } = getCanvasPosFromTouch(e);
      if (y >= canvas.height || x >= leftWidth) return;
      drawing = true;
      originalPoints = [];
      aiPoints = null;
      resetProgress();
      const [nx, ny] = screenToNorm(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
      setStatus("Recording stroke...");
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
      if (!drawing) return;
      e.preventDefault();
      const { x, y } = getCanvasPosFromTouch(e);
      if (y >= canvas.height || x >= leftWidth) return;
      const [nx, ny] = screenToNorm(x, y);
      originalPoints.push([nx, ny]);
      redraw(false);
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      if (!drawing) return;
      drawing = false;
      setStatus(`Recorded ${originalPoints.length} points.`);
    }, { passive: false });

    // ── TF.js model: t -> (x,y) ────────────────────────
    function buildModel() {
      const m = tf.sequential();
      m.add(tf.layers.dense({ units: 64, inputShape: [1], activation: "tanh" }));
      m.add(tf.layers.dense({ units: 64, activation: "tanh" }));
      m.add(tf.layers.dense({ units: 2 }));
      m.compile({
        optimizer: tf.train.adam(0.01),
        loss: "meanSquaredError",
      });
      return m;
    }

    async function trainModelOnStroke(points) {
      const T = points.length;
      const t = tf.linspace(0, 1, T).reshape([T, 1]);      // (T,1)
      const y = tf.tensor2d(points);                        // (T,2)

      model = buildModel();
      setStatus("Training AI (browser neural net)...");
      resetProgress();

      await model.fit(t, y, {
        epochs: TOTAL_EPOCHS,
        batchSize: 32,
        shuffle: true,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            updateProgress(epoch, logs.loss);
            if ((epoch + 1) % 20 === 0 || epoch + 1 === TOTAL_EPOCHS) {
              setStatus(`Training... epoch ${epoch + 1}/${TOTAL_EPOCHS}`);
            }
          }
        }
      });

      t.dispose();
      y.dispose();
      setStatus("Training done. Click 'Draw with AI'.");
    }

    async function generateAI(points) {
      if (!model) {
        setStatus("No model yet. Train AI first.");
        return;
      }
      const T = points.length;
      const t = tf.linspace(0, 1, T).reshape([T, 1]);
      const pred = model.predict(t);
      const arr = await pred.array();
      t.dispose();
      pred.dispose();

      aiPoints = arr.map(([x, y]) => [
        Math.min(Math.max(x, 0), 1),
        Math.min(Math.max(y, 0), 1),
      ]);
      redraw(true);
      setStatus("Original (left) vs AI (right, blue).");
    }

    // ── Buttons ────────────────────────────────────────
    document.getElementById("btn-train").onclick = async () => {
      if (originalPoints.length < 5) {
        setStatus("Draw something on the left first.");
        return;
      }
      await trainModelOnStroke(originalPoints);
    };

    document.getElementById("btn-draw-ai").onclick = async () => {
      if (originalPoints.length < 5) {
        setStatus("No stroke yet.");
        return;
      }
      await generateAI(originalPoints);
    };

    document.getElementById("btn-clear").onclick = () => {
      originalPoints = [];
      aiPoints = null;
      clearCanvas();
      resetProgress();
      setStatus("Cleared.");
    };

    document.getElementById("btn-save").onclick = () => {
      const link = document.createElement("a");
      link.download = "aidraw_web.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
      setStatus("Image downloaded.");
    };
  </script>
</body>
</html>
